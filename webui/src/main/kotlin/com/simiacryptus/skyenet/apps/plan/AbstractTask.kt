package com.simiacryptus.skyenet.apps.plan

import com.fasterxml.jackson.annotation.JsonTypeInfo
import com.fasterxml.jackson.databind.DatabindContext
import com.fasterxml.jackson.databind.JavaType
import com.fasterxml.jackson.databind.annotation.JsonTypeIdResolver
import com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase
import com.simiacryptus.diff.FileValidationUtils
import com.simiacryptus.jopenai.API
import com.simiacryptus.jopenai.describe.Description
import com.simiacryptus.skyenet.apps.plan.AbstractTask.PlanTaskBase
import com.simiacryptus.skyenet.set
import com.simiacryptus.skyenet.webui.application.ApplicationInterface
import com.simiacryptus.skyenet.webui.session.SessionTask
import java.io.File
import java.nio.file.FileSystems
import java.nio.file.Files
import java.nio.file.Path
import kotlin.streams.asSequence

abstract class AbstractTask<T : PlanTaskBase>(
    val planSettings: PlanSettings,
    val planTask: T?
) {
    class PlanTaskTypeIdResolver : TypeIdResolverBase() {
        override fun idFromValue(value: Any): String {
            return when (value) {
                is PlanTaskBase -> value.task_type?.let {
                    TaskType.valueOf(it).name
                } ?: throw IllegalArgumentException("Unknown task type")

                else -> throw IllegalArgumentException("Unexpected value type: ${value.javaClass}")
            }
        }

        override fun idFromValueAndType(value: Any, suggestedType: Class<*>): String {
            return idFromValue(value)
        }

        override fun typeFromId(context: DatabindContext, id: String): JavaType {
            val taskType = TaskType.valueOf(id.replace(" ", ""))
            val subType = context.constructType(taskType.taskDataClass)
            return subType
        }

        override fun getMechanism(): JsonTypeInfo.Id {
            return JsonTypeInfo.Id.NAME
        }
    }

    @Suppress("PropertyName")
    @JsonTypeIdResolver(PlanTaskTypeIdResolver::class)
    open class PlanTaskBase(
        @Description("An enumeration indicating the type of task to be executed. Must be a single value from the TaskType enum.")
        val task_type: String? = null,
        @Description("A detailed description of the specific task to be performed, including its role in the overall plan and its dependencies on other tasks.")
        var task_description: String? = null,
        @Description("A list of IDs of tasks that must be completed before this task can be executed. This defines upstream dependencies ensuring proper task order and information flow.")
        var task_dependencies: List<String>? = null,
        @Description("A list of file paths specifying the input files required by this task. These may be outputs from dependent tasks, facilitating data transfer between tasks.")
        val input_files: List<String>? = null,
        @Description("A list of file paths specifying the output files generated by this task. These may serve as inputs for subsequent tasks, enabling information sharing.")
        val output_files: List<String>? = null,
        @Description("The current execution state of the task. Important for coordinating task execution and managing dependencies.")
        var state: TaskState? = null
    )

    var state: TaskState? = TaskState.Pending
    protected val codeFiles = mutableMapOf<Path, String>()

    protected open val root: Path
        get() = planSettings.workingDir?.let { File(it).toPath() }
            ?: throw IllegalStateException("Working directory not set")

    enum class TaskState {
        Pending,
        InProgress,
        Completed,
    }

    protected fun getPriorCode(planProcessingState: PlanProcessingState) =
        planTask?.task_dependencies?.joinToString("\n\n\n") { dependency ->
            """
        |# $dependency
        |
        |${planProcessingState.taskResult[dependency] ?: ""}
        """.trimMargin()
        } ?: ""

    protected fun getInputFileCode(): String =
        ((planTask?.input_files ?: listOf()) + (planTask?.output_files ?: listOf()))
        .flatMap { pattern: String ->
            val matcher = FileSystems.getDefault().getPathMatcher("glob:$pattern")
            Files.walk(root).asSequence()
                .filter { path ->
                    matcher.matches(root.relativize(path)) &&
                            FileValidationUtils.isLLMIncludable(path.toFile())
                }
                .map { path ->
                    root.relativize(path).toString()
                }
                .toList()
        }
        .distinct()
        .sortedBy { it }
        .joinToString("\n\n") { relativePath ->
            val file = root.resolve(relativePath).toFile()
            try {
                """
                |# $relativePath
                |
                |$TRIPLE_TILDE
                |${codeFiles[file.toPath()] ?: file.readText()}
                |$TRIPLE_TILDE
                """.trimMargin()
            } catch (e: Throwable) {
                log.warn("Error reading file: $relativePath", e)
                ""
            }
        }

    protected fun acceptButtonFooter(ui: ApplicationInterface, fn: () -> Unit): String {
        val footerTask = ui.newTask(false)
        lateinit var textHandle: StringBuilder
        textHandle = footerTask.complete(ui.hrefLink("Accept", classname = "href-link cmd-button") {
            try {
                textHandle.set("""<div class="cmd-button">Accepted</div>""")
                footerTask.complete()
            } catch (e: Throwable) {
                log.warn("Error", e)
            }
            fn()
        })!!
        return footerTask.placeholder
    }

    abstract fun promptSegment(): String

    abstract fun run(
        agent: PlanCoordinator,
        taskId: String,
        userMessage: String,
        plan: Map<String, PlanTaskBase>,
        planProcessingState: PlanProcessingState,
        task: SessionTask,
        api: API
    )

    companion object {
        private val log = org.slf4j.LoggerFactory.getLogger(AbstractTask::class.java)
    }
}