package com.simiacryptus.skyenet.apps.plan

import com.fasterxml.jackson.annotation.JsonTypeInfo
import com.fasterxml.jackson.databind.DatabindContext
import com.fasterxml.jackson.databind.JavaType
import com.fasterxml.jackson.databind.annotation.JsonTypeIdResolver
import com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase
import com.simiacryptus.jopenai.API
import com.simiacryptus.jopenai.describe.Description
import com.simiacryptus.jopenai.models.ApiModel
import com.simiacryptus.jopenai.util.ClientUtil.toContentList
import com.simiacryptus.skyenet.Discussable
import com.simiacryptus.skyenet.apps.plan.PlanUtil.diagram
import com.simiacryptus.skyenet.apps.plan.PlanUtil.executionOrder
import com.simiacryptus.skyenet.apps.plan.PlanUtil.filterPlan
import com.simiacryptus.skyenet.apps.plan.PlanUtil.render
import com.simiacryptus.skyenet.apps.plan.PlanningTask.PlanningTaskData
import com.simiacryptus.skyenet.core.actors.ParsedResponse
import com.simiacryptus.skyenet.webui.application.ApplicationInterface
import com.simiacryptus.skyenet.webui.session.SessionTask
import com.simiacryptus.util.JsonUtil
import org.slf4j.LoggerFactory

class PlanningTask(
    planSettings: PlanSettings,
    planTask: PlanningTaskData?
) : AbstractTask<PlanningTaskData>(planSettings, planTask) {
    class PlanningTaskData(
        @Description("An enumeration indicating the type of task to be executed. Must be a single value from the TaskType enum.")
        task_type: String? = null,
        @Description("A detailed description of the specific task to be performed, including its role in the overall plan and its dependencies on other tasks.")
        task_description: String? = null,
        @Description("A list of IDs of tasks that must be completed before this task can be executed. This defines upstream dependencies ensuring proper task order and information flow.")
        task_dependencies: List<String>? = null,
        @Description("A list of file paths specifying the input files required by this task. These may be outputs from dependent tasks, facilitating data transfer between tasks.")
        input_files: List<String>? = null,
        @Description("A list of file paths specifying the output files generated by this task. These may serve as inputs for subsequent tasks, enabling information sharing.")
        output_files: List<String>? = null,
        @Description("The current execution state of the task. Important for coordinating task execution and managing dependencies.")
        state: TaskState? = TaskState.Pending,
    ) : PlanTaskBase(
        task_type = task_type,
        task_description = task_description,
        task_dependencies = task_dependencies,
        input_files = input_files,
        output_files = output_files,
        state = state
    )

    @JsonTypeIdResolver(PlanTaskTypeIdResolver::class)
    interface TaskBreakdownInterface<T : PlanTaskBase> {
        val tasksByID: Map<String, T>?
    }

    data class TaskBreakdownResult(
        @Description("A map where each task ID is associated with its corresponding PlanTask object. Crucial for defining task relationships and information flow.")
        override val tasksByID: Map<String, PlanTaskBase>? = null,
    ) : TaskBreakdownInterface<PlanTaskBase>


    class PlanTaskTypeIdResolver : TypeIdResolverBase() {
        override fun idFromValue(value: Any): String {
            return when (value) {
                is PlanTaskBase -> value.task_type?.let {
                    TaskType.valueOf(it).name
                } ?: throw IllegalArgumentException("Unknown task type")
                else -> throw IllegalArgumentException("Unexpected value type: ${value.javaClass}")
            }
        }
        override fun idFromValueAndType(value: Any, suggestedType: Class<*>): String {
            return idFromValue(value)
        }
        override fun typeFromId(context: DatabindContext, id: String): JavaType {
            val taskType = TaskType.valueOf(id.replace(" ", ""))
            val subType = context.constructType(taskType.taskDataClass)
            return subType
        }
        override fun getMechanism(): JsonTypeInfo.Id {
            return JsonTypeInfo.Id.NAME
        }
    }


    data class ExecutionTask(
        @Description("The command line for the task (Only applicable in CommandAutoFix tasks).")
        val command: List<String>? = null,
        @Description("The working directory relative to the root directory (e.g., \".\" or \"./subdir\") (Only applicable for CommandAutoFix and RunShellCommand tasks)")
        val workingDir: String? = null,
    )

    private val taskBreakdownActor by lazy { planSettings.planningActor<TaskBreakdownInterface<PlanTaskBase>>() }

    override fun promptSegment(): String {
        return """
        |Task Planning:
        |  * Perform high-level planning and organization of tasks.
        |  * Decompose the overall goal into smaller, actionable tasks based on current information, ensuring proper information flow between tasks.
        |  * Specify prior tasks and the overall goal of the task, emphasizing dependencies to ensure each task is connected with its upstream and downstream tasks.
        |  * Dynamically break down tasks as new information becomes available.
        |  * Carefully consider task dependencies to ensure efficient information transfer and coordination between tasks.
        |  * Design the task structure to maximize parallel execution where possible, while respecting necessary dependencies.
        |  * **Note**: A planning task should refine the plan based on new information, optimizing task relationships and dependencies, and should not initiate execution.
        |  * Ensure that each task utilizes the outputs or side effects of its upstream tasks, and provides outputs or side effects for its downstream tasks.
        """.trimMargin()
    }

    override fun run(
        agent: PlanCoordinator,
        taskId: String,
        userMessage: String,
        plan: Map<String, PlanTaskBase>,
        planProcessingState: PlanProcessingState,
        task: SessionTask,
        api: API
    ) {
        val newTask = agent.ui.newTask(false).apply { add(placeholder) }
        fun toInput(s: String) = listOf(
            userMessage,
            JsonUtil.toJson(plan.entries.associate { it.key to it.value }),
            getPriorCode(planProcessingState),
            getInputFileCode(),
            s
        ).filter { it.isNotBlank() }
        val subPlan = if (planSettings.allowBlocking && !planSettings.autoFix) {
            createSubPlanDiscussable(newTask, userMessage, ::toInput, api, agent.ui).call().obj
        } else {
            val design = taskBreakdownActor.answer(
                toInput("Expand ${planTask?.task_description ?: ""}"),
                api = api
            )
            render(
                withPrompt = PlanUtil.TaskBreakdownWithPrompt(
                    plan = filterPlan { design.obj.tasksByID } ?: emptyMap(),
                    planText = design.text,
                    prompt = userMessage
                ),
                ui = agent.ui
            )
            design.obj
        }
        executeSubTasks(agent, userMessage, filterPlan { subPlan.tasksByID } ?: emptyMap(), task, api)
    }

    private fun createSubPlanDiscussable(
        task: SessionTask,
        userMessage: String,
        toInput: (String) -> List<String>,
        api: API,
        ui: ApplicationInterface
    ) = Discussable(
        task = task,
        userMessage = { "Expand ${planTask?.task_description ?: ""}" },
        heading = "",
        initialResponse = { it: String -> taskBreakdownActor.answer(toInput(it), api = api) as ParsedResponse<TaskBreakdownInterface<*>> },
        outputFn = { design : ParsedResponse<TaskBreakdownInterface<*>> ->
            render(
                withPrompt = PlanUtil.TaskBreakdownWithPrompt(
                    plan = filterPlan { design.obj.tasksByID } ?: emptyMap(),
                    planText = design.text,
                    prompt = userMessage
                ),
                ui = ui
            )
        },
        ui = ui,
        reviseResponse = { userMessages: List<Pair<String, ApiModel.Role>> ->
            taskBreakdownActor.respond(
                messages = userMessages.map { ApiModel.ChatMessage(it.second, it.first.toContentList()) }
                    .toTypedArray<ApiModel.ChatMessage>(),
                input = toInput("Expand ${planTask?.task_description ?: ""}\n${JsonUtil.toJson(this)}"),
                api = api
            ) as ParsedResponse<TaskBreakdownInterface<*>>
        },
    )

    private fun executeSubTasks(
        agent: PlanCoordinator,
        userMessage: String,
        subPlan: Map<String, PlanTaskBase>,
        parentTask: SessionTask,
        api: API
    ) {
        val subPlanTask = agent.ui.newTask(false)
        parentTask.add(subPlanTask.placeholder)
        val subTasks = subPlan ?: emptyMap()
        val planProcessingState = PlanProcessingState(subTasks.toMutableMap())
        agent.executePlan(
            task = subPlanTask,
            diagramBuffer = subPlanTask.add(diagram(agent.ui, planProcessingState.subTasks)),
            subTasks = subTasks,
            diagramTask = subPlanTask,
            planProcessingState = planProcessingState,
            taskIdProcessingQueue = executionOrder(subTasks).toMutableList(),
            pool = agent.pool,
            userMessage = userMessage,
            plan = subPlan,
            api = api,
        )
        subPlanTask.complete()
    }

    companion object {
        private val log = LoggerFactory.getLogger(PlanningTask::class.java)
    }
}